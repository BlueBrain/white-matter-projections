#!/usr/bin/env python
'''white-matter application'''
from __future__ import print_function
from contextlib import contextmanager

from glob import glob
import logging
import os

import click
import numpy as np
import pandas as pd
from white_matter_projections import utils


L = logging.getLogger(__name__)
# Allow for matplotlib to be interactive or writing to file
plt = None


def print_color(s, *args, **kwargs):
    '''output text in green'''
    if args:
        s = s % args
    color = kwargs.get('color', 'green')
    click.echo(click.style(s, fg=color))


@click.group()
@click.version_option()
@click.option('-v', '--verbose', count=True)
@click.option('-m', '--interactive-matplotlib', is_flag=True)
@click.pass_context
def cli(ctx, verbose, interactive_matplotlib):
    '''White Matter Generation'''
    global plt  # pylint: disable=global-statement
    if not interactive_matplotlib:
        import matplotlib
        matplotlib.use('Agg')  # noqa

    import matplotlib.pyplot
    plt = matplotlib.pyplot

    if interactive_matplotlib:
        @contextmanager
        def figure(name):  # pylint: disable=unused-argument
            '''get a figure'''
            yield plt.figure()
            plt.show()
    else:
        @contextmanager
        def figure(name):
            '''get a figure'''
            plt.close('all')
            fig = plt.gcf()
            fig.set_size_inches(20, 20)
            fig.tight_layout()

            yield fig

            if not name.endswith('.png'):
                name += '.png'

            plt.savefig(name)
            print_color('Wrote: %s', name)

    ctx.obj['figure'] = figure

    logging.basicConfig(level=(logging.WARNING,
                               logging.INFO,
                               logging.DEBUG)[min(verbose, 2)],
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')


@cli.command()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def repl(ctx, config):  # pylint: disable=unused-argument
    '''Start ipython REPL'''
    import IPython
    config = utils.Config(config)
    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         config.recipe.layer_profiles)
    IPython.embed(banner1='You have access to: config, norm_layer_profiles')


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def macro(ctx, config):
    '''Macro connectivity: based on recipe, but not concretized with circuit details'''
    ctx.obj['config'] = utils.Config(config)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density(ctx, target):
    '''Stacked barchart of incoming regions synapse density for the selected target '''
    config, recipe = ctx.obj['config'], ctx.obj['config'].recipe

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         recipe.layer_profiles)

    name = 'stacked_region_%s' % target
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        stacked_density = recipe.get_target_region_density_sources(norm_layer_profiles, target)
        stacked_density.plot(kind='bar', stacked=True, ax=ax)
        ax.set_title('Vertical Profile of incoming regions for target: ' + target)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density_module(ctx, target):
    import altair as alt
    config, recipe = ctx.obj['config'], ctx.obj['config'].recipe

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         recipe.layer_profiles)

    stacked_density = recipe.get_target_region_density_modules(
        norm_layer_profiles, target, config.config['module_grouping'])

    stacked_density = (stacked_density
                       .T
                       .reset_index()
                       .melt('Source')
                       )
    order = alt.Order('Source', sort='ascending')
    _ = (alt.Chart(stacked_density)
         .properties(height=1000, width=400,
                     title='%s Layer by Source Population' % target)
         .mark_bar()
         .encode(x=alt.X('Target:N', axis=alt.Axis(title='Layer')),
                 y=alt.Y('sum(value):Q', axis=alt.Axis(title='Density')),
                 color=alt.Color('Source'),
                 order=order,
                 tooltip=['Source', 'Target', 'value']
                 )
         .save('stacked_density_%s.html' % target)
         )


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def connectivity(ctx, contra):
    '''Plot connectivity matrix of of synapse densities per region'''
    from white_matter_projections import display
    config = ctx.obj['config']

    hemisphere = 'contra' if contra else 'ipsi'
    df = config.recipe.get_connection_density_map(hemisphere)
    df = utils.perform_module_grouping(df, config.config['module_grouping'])

    name = 'connectivity_%s' % hemisphere
    with ctx.obj['figure'](name) as fig:
        title = 'Connection synapse density - %s' % hemisphere
        display.draw_connectivity(fig, df, title, config.config['module_grouping_color'])


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def target_density(ctx, contra):
    '''Plot synapse density in target regions, by layer'''
    import seaborn as sns
    config = ctx.obj['config']

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         config.recipe.layer_profiles)

    hemisphere = 'contra' if contra else 'ipsi'
    df = config.recipe.get_target_region_density(norm_layer_profiles, hemisphere)

    cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True, center='light')
    cmap.set_bad(color='white')
    df = df.replace(0., np.NaN)

    name = 'target_density_contra' if contra else 'target_density_ipsi'
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        sns.heatmap(df, cmap=cmap, square=True, xticklabels=1, yticklabels=1, linewidth=0.5, ax=ax)


@macro.command()
@click.pass_context
def source_mapping_triangles(ctx):
    '''Plot all triangles of the source regions on the flat-map'''
    from white_matter_projections import display
    config = ctx.obj['config']

    name = 'src_mapping_triangles'
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        display.plot_allen_coloured_flat_map(ax, config, regions='all', only_right=True)
        display.plot_source_region_triangles(ax, config, regions='all', only_right=True)


@macro.command()
@click.option('-p', '--population', required=True)
@click.pass_context
def stats(ctx, population):
    '''Calculate stats per population'''
    config = ctx.obj['config']

    region_names = set(config.recipe.populations.query('population == @population').subregion)
    population, region_names = population, region_names  # trick pylint

    sources = config.recipe.projections.query('source_population == @population')
    if len(sources):
        region_cells = config.get_cells().query('region in @region_names')
        print_color('Potential source cells in population: %d', len(region_cells))

        print_color('Projections with population as source:')
        out = sources.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['target_population', 'projection_name', 'target_density'])
        print(out)

    targets = config.recipe.projections.query('target_population == @population')
    if len(targets):
        region_cells = config.get_cells().query('region in @region_names')
        print_color('Potential target cells in population: %d', len(region_cells))

        print_color('Projections with population as target:')
        out = targets.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['source_population', 'projection_name', 'target_density'])
        print(out)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def micro(ctx, config, output):
    '''Micro connectivity: based on recipe, including circuit details'''
    ctx.obj['config'] = utils.Config(config)
    ctx.obj['output'] = output
    utils.ensure_path(output)


@micro.command()
@click.pass_context
def download_streamlines(ctx):
    '''Download as many streamlines as possible used in recipe from AIBS'''
    from white_matter_projections import streamlines
    config, output = ctx.obj['config'], ctx.obj['output']

    streamline_csvs = os.path.join(output, 'streamlines')
    if not os.path.exists(streamline_csvs):
        L.info('Downlading streamlines to %s', streamline_csvs)
        utils.ensure_path(streamline_csvs)
        centroids = streamlines.get_connected_centroids(config.flat_map, config.recipe)
        missing = streamlines.download_streamlines(centroids, config.hierarchy, streamline_csvs)
        if missing:
            L.info('Missing streamlines: %s', missing)

    csv_paths = glob(os.path.join(streamline_csvs, '*.csv'))
    metadata, paths = streamlines.convert_csvs(
        csv_paths, center_line_3d=config.flat_map.center_line_3d)
    streamlines.save(output, metadata, paths)


@micro.command()
@click.pass_context
def allocate(ctx):
    '''Allocate source cell GIDS by region, and store them for use when assigning target GIDS'''
    from white_matter_projections import micro
    config, output = ctx.obj['config'], ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    if os.path.exists(allocations_path):
        print_color('Already have created %s, delete it if it needs to be recreated',
                    allocations_path, color='red')
        return

    allocations = micro.allocate_projections(config.recipe, config.get_cells)

    micro.save_allocations(allocations_path, allocations)


@micro.command()
@click.option('-p', '--population', 'target_population', required=True)
@click.pass_context
def sample_all(ctx, target_population):
    '''create and save segment sample regions for target_population'''
    from white_matter_projections import sampling

    config, output = ctx.obj['config'], ctx.obj['output']

    target_population = target_population
    index_base = config.config['indices']
    population = config.recipe.populations.query('population == @target_population')
    brain_regions = config.atlas.load_data('brain_regions')

    sampling.sample_all(output, index_base, population, brain_regions)


@micro.command()
@click.option('-p', '--population', 'target_population', required=True)
@click.pass_context
def subsample(ctx, target_population):
    from white_matter_projections import sampling
    config, output = ctx.obj['config'], ctx.obj['output']

    sampling.subsample_per_target(output, config, target_population)


@micro.command()
@click.option('-p', '--population', 'target_population', required=True)
@click.option('-s', '--side', type=click.Choice(['left', 'right']), default='right')
@click.pass_context
def assignment(ctx, target_population, side):
    from white_matter_projections import micro, mapping, sampling
    config, output = ctx.obj['config'], ctx.obj['output']
    recipe = config.recipe

    join_cols = ['projection_name', 'source_population']
    hemisphere = recipe.projections.set_index(join_cols).hemisphere

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = (micro.load_allocations(allocations_path, recipe.projections_mapping)
                   .query('target_population == @target_population')
                   .join(hemisphere, on=join_cols)
                   )

    mapper = mapping.CommonMapper.load_default(config)
    projections_mapping = config.recipe.projections_mapping
    closest_count = config.config['assignment']['closest_count']
    micro.assignment(output, config, allocations, projections_mapping, mapper, side, closest_count)


@micro.command()
@click.option('-p', '--population', 'target_population', required=True)
@click.option('-s', '--side', type=click.Choice(('left', 'right')), default='right')
@click.pass_context
def concat_assignments(ctx, target_population, side):
    config, output = ctx.obj['config'], ctx.obj['output']
    projections = config.recipe.projections

    if target_population == 'all':
        target_populations = projections.target_population.unique()
        target_populations = set(target_populations)
        target_populations.remove('ORBvl_ALL_LAYERS')
        target_populations = list(target_populations)
    else:
        target_populations = (target_population, )

    base_path = os.path.join(output, micro.ALLOCATED_PATH, side)
    for target_population in target_populations:
        output_path = os.path.join(output, '%s_%s_proj_nrn.feather' % (target_population, side))
        if os.path.exists(output_path):
            L.warning('Already have %s, delete it if it needs to be recreated', output_path)
            continue

        L.info('Doing target_population: %s', target_population)
        projection_names = projections.query('target_population == @target_population')
        syns, missing = [], []
        for name, synapse_type in projection_names[['projection_name', 'synapse_type_name']].values:
            path = os.path.join(base_path, name + '.feather')
            if not os.path.exists(path):
                missing.append(name)
                continue
            L.debug('Loading: %s', path)
            new_syns = utils.read_frame(path)
            new_syns['synapse_type_name'] = int(synapse_type[-1])
            syns.append(new_syns)

        L.debug('Missing feathers for %s', missing)

        L.debug('Concat %d frames', len(syns))
        syns = pd.concat(syns)

        syns['sgid'] = pd.to_numeric(syns['sgid'], downcast='unsigned')

        L.debug('Sorting %s', output_path)
        syns.sort_values(['tgid', 'sgid'], inplace=True)
        syns.reset_index(drop=True, inplace=True)
        L.debug('Writing %s', output_path)
        utils.write_frame(output_path, syns)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def analysis(ctx, config, output):
    '''general analysis'''
    ctx.obj['config'] = utils.Config(config)
    assert os.path.exists(output)
    ctx.obj['output'] = output


@analysis.command()
@click.pass_context
def source_locations(ctx):
    '''Plot the source locations, after allocation, but before used'''
    from white_matter_projections import display, micro, mapping
    config, output = ctx.obj['config'], ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = micro.load_allocations(allocations_path, config.recipe.projections_mapping)

    sgids = np.hstack(allocations.sgids.values).ravel()
    src_cells = config.get_cells()
    mapper = mapping.CommonMapper.load_default(config)

    name = 'src_positions.png'
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        ax.set_aspect('equal')

        display.plot_allen_coloured_flat_map(ax, config, regions='all')
        display.plot_flat_cells(ax, src_cells, sgids, mapper)


@analysis.command()
@click.option('-p', '--population', 'target_population', required=True)
@click.option('-s', '--side', type=click.Choice(['left', 'right']), default='right')
@click.pass_context
def used_locations(ctx, target_population, side):
    '''Plot the source locations for particular target region, but only ones used'''
    from white_matter_projections import display, micro, mapping
    config, output = ctx.obj['config'], ctx.obj['output']

    files = glob(os.path.join(output, micro.ASSIGNMENT_PATH, side, '*.feather'))

    sgids = [utils.read_frame(f, columns=['sgid']) for f in files]
    sgids = pd.concat(sgids)

    src_cells = config.get_cells()
    mapper = mapping.CommonMapper.load_default(config)

    name = 'used_src_positions_%s_%s.png' % (target_population, side)
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        ax.set_aspect('equal')

        display.plot_allen_coloured_flat_map(ax, config, regions='all')
        display.plot_flat_cells(ax, src_cells, sgids, mapper)

        tgt_region = utils.population2region(config.recipe.populations, target_population)
        regions = set(config.regions)
        regions.discard(tgt_region.split('_')[0])
        display.plot_source_region_triangles(ax, config, regions)


@analysis.command()
@click.option('-n', '--name', 'projection_name')
@click.option('-s', '--side', type=click.Choice(['left', 'right']), default='right')
@click.pass_context
def projection(ctx, projection_name, side):
    from white_matter_projections import display, micro, mapping
    config, output = ctx.obj['config'], ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = (micro.load_allocations(allocations_path, config.recipe.projections_mapping)
                   .set_index('projection_name'))

    name = str(os.path.join(output, 'projection_%s_%s' % (projection_name, side)))
    if os.path.exists(name):
        return

    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        ax.set_aspect('equal')

        path = os.path.join(output, micro.ASSIGNMENT_PATH, side, projection_name + '.feather')
        if not os.path.exists(path):
            L.info('Missing path for loading projections: %s', path)
            return

        syns = utils.read_frame(path, columns=['sgid', 'z'])

        #variance = projections_mapping[projection_name]['variance']
        #print_color('%d sgids allocated, %d used (%0.2f) -- %0.4f mapping variance',
        #            len(all_sgids), len(used_sgids), float(len(used_sgids)) / len(all_sgids), variance)

        #ax.set_title('%s[%s] w/ Variance: %0.2f' % (projection_name, side, variance))

        display.plot_allen_coloured_flat_map(ax, config, regions='all')
        display.draw_projection(ax, config, allocations, syns, projection_name, side)


@analysis.command()
@click.option('-p', '--population', required=True, default='ACAd_6')
@click.pass_context
def allocation_stats(ctx, population):
    '''Based on the allocations created by 'micro allocate', display stats'''
    from white_matter_projections import micro
    config, recipe, output = ctx.obj['config'], ctx.obj['config'].recipe, ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = micro.load_allocations(allocations_path, recipe.projections_mapping)

    fractions, interactions = micro.allocation_stats(
        recipe, config.get_cells, allocations, population)

    print_color('Population Fractions')
    print(fractions.to_string(max_rows=None))

    print('\n')

    print_color('Population Interactions')
    print(interactions
          .sort_values('absolute_difference', ascending=False)
          .to_string(max_rows=None))
    print_color('Mean absolute difference: %0.2f', interactions['absolute_difference'].abs().mean())


if __name__ == '__main__':
    cli(obj={})  # pylint: disable=no-value-for-parameter,unexpected-keyword-arg
