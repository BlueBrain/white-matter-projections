#!/usr/bin/env python
'''white-matter application'''
from __future__ import print_function

import logging
import os

import click
import numpy as np
import pandas as pd
from white_matter_projections import utils


L = logging.getLogger(__name__)
# Allow for matplotlib to be interactive or writing to file
plt = None


def print_color(s, *args, **kwargs):
    '''output text in green'''
    if args:
        s = s % args
    color = kwargs.get('color', 'green')
    click.echo(click.style(s, fg=color))


@click.group()
@click.version_option()
@click.option('-v', '--verbose', count=True)
@click.option('-m', '--interactive-matplotlib', is_flag=True)
@click.pass_context
def cli(ctx, verbose, interactive_matplotlib):
    global plt
    if not interactive_matplotlib:
        import matplotlib
        matplotlib.use('Agg')  # noqa

    import matplotlib.pyplot
    plt = matplotlib.pyplot

    if interactive_matplotlib:
        def figure():
            '''get a figure'''
            return plt.figure()

        def display(_):
            '''display a figure'''
            plt.show()
    else:
        def figure():
            '''get a figure'''
            plt.close('all')
            fig = plt.gcf()
            fig.set_size_inches(20, 20)
            fig.tight_layout()
            return fig

        def display(name):
            '''display a figure'''
            plt.savefig(name)
            print_color('Wrote: %s', name)


    ctx.obj['display'] = display
    ctx.obj['figure'] = figure

    logging.basicConfig(level=(logging.WARNING,
                               logging.INFO,
                               logging.DEBUG)[min(verbose, 2)],
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')


@cli.command()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def repl(ctx, config):
    import IPython

    config = utils.Config(config)

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         config.recipe.layer_profiles)

    IPython.embed(banner1='You have access to: config, norm_layer_profiles')


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def macro(ctx, config):
    ctx.obj['config'] = utils.Config(config)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density(ctx, target):
    '''stacked target density

    Colored by source:
        1. MODULE
        2. LAYER (or subregion, i.e. 5it and 5pt are separate)
        3. REGION
    '''
    recipe = ctx.obj['config'].recipe
    layer_heights = ctx.obj['config'].region_layer_heights

    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    fig = ctx.obj['figure']()
    ax = fig.gca()
    stacked_density = recipe.get_target_region_density_sources(norm_layer_profiles, target)
    stacked_density.plot(kind='bar', stacked=True, ax=ax)
    ax.set_title('Vertical Profile of incoming regions for target: ' + target)
    ctx.obj['display']('stacked_region_%s.png' % target)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density_module(ctx, target):
    config = ctx.obj['config'].config
    recipe = ctx.obj['config'].recipe

    layer_heights = utils.region_layer_heights(config['region_layer_heights'])
    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    import altair as alt
    modules = config['module_grouping']
    stacked_density = recipe.get_target_region_density_modules(
        norm_layer_profiles, target, modules)

    stacked_density = (stacked_density
                       .T
                       .reset_index()
                       .melt('Source')
                       )
    order = alt.Order('Source', sort='ascending')
    chart = (alt.Chart(stacked_density)
             .properties(height=1000, width=400,
                         title='%s Layer by Source Population' % target)
             .mark_bar()
             .encode(
                 x=alt.X('Target:N', axis=alt.Axis(title='Layer')),
                 y=alt.Y('sum(value):Q', axis=alt.Axis(title='Density')),
                 color=alt.Color('Source'),
                 order=order,
                 tooltip=['Source', 'Target', 'value']
             )
             .save('stacked_density_%s.html' % target)
             )


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def connectivity(ctx, contra):
    from white_matter_projections import display
    config = ctx.obj['config'].config
    recipe = ctx.obj['config'].recipe

    hemisphere = 'contra' if contra else 'ipsi'
    df = recipe.get_connection_density_map(hemisphere)

    df = utils.perform_module_grouping(df, config['module_grouping'])

    fig = ctx.obj['figure']()

    title = 'Connection synapse density - ' + 'Contralateral' if contra else 'Ipsilateral'
    display.draw_connectivity(fig, df, title, config['module_grouping_color'])

    name = 'connectivity_contra.png' if contra else 'connectivity.png'
    ctx.obj['display'](name)


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def target_density(ctx, contra):
    import seaborn as sns
    recipe = ctx.obj['config'].recipe
    layer_heights = ctx.obj['config'].region_layer_heights

    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    hemisphere = 'contra' if contra else 'ipsi'
    df = recipe.get_target_region_density(norm_layer_profiles, hemisphere)

    cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True, center='light')
    cmap.set_bad(color='white')
    df = df.replace(0., np.NaN)

    fig = ctx.obj['figure']()
    ax = fig.gca()
    sns.heatmap(df, cmap=cmap, square=True, xticklabels=1, yticklabels=1, linewidth=0.5, ax=ax)
    name = 'target_density_contra.png' if contra else 'target_density.png'
    ctx.obj['display'](name)


@macro.command()
@click.pass_context
def source_mapping_triangles(ctx):
    from white_matter_projections import display, flat_mapping

    fig = ctx.obj['figure']()
    ax = fig.gca()
    display.plot_source_region_triangles(ax, ctx.obj['config'])

    name = 'src_mapping_triangles.png'
    ctx.obj['display'](name)


@macro.command()
@click.option('-p', '--population', required=True)
@click.pass_context
def stats(ctx, population):
    config = ctx.obj['config']

    region_names = set(config.recipe.populations.query('population == @population').subregion)
    region_names = region_names  # trick pylint

    sources = config.recipe.projections.query('source_population == @population')
    if len(sources):
        region_cells = config.cells().query('region in @region_names')
        print_color('Potential source cells in population: %d', len(region_cells))

        print_color('Projections with population as source:')
        out = sources.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['target_population', 'projection_name', 'target_density'])
        print(out)

    targets = config.recipe.projections.query('target_population == @population')
    if len(targets):
        region_cells = config.cells(include_all=True).query('region in @region_names')
        print_color('Potential target cells in population: %d', len(region_cells))

        print_color('Projections with population as target:')
        out = targets.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['source_population', 'projection_name', 'target_density'])
        print(out)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def micro(ctx, config, output):
    ctx.obj['config'] = utils.Config(config)
    ctx.obj['output'] = output

    if not os.path.exists(output):
        os.makedirs(output)


@micro.command()
@click.pass_context
def allocate(ctx):
    from white_matter_projections import micro
    config, output = ctx.obj['config'], ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    if os.path.exists(allocations_path):
        print_color('Already have created %s, delete it if it needs to be recreated',
                    allocations_path, color='red')
        return

    allocations = micro.allocate_projections(config.recipe, config.cells())

    micro.save_allocations(allocations_path, allocations)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def analysis(ctx, config, output):
    '''analysis'''
    ctx.obj['config'] = utils.Config(config)
    assert os.path.exists(output)
    ctx.obj['output'] = output


@analysis.command()
@click.option('-p', '--population', required=True, default='ACAd_6')
@click.pass_context
def allocation_stats(ctx, population):
    from white_matter_projections import micro
    config, output = ctx.obj['config'], ctx.obj['output']
    recipe = config.recipe

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = micro.load_allocations(allocations_path, config.recipe.projections_mapping)

    fractions, interactions = micro.allocation_stats(recipe.ptypes,
                                                     recipe.populations,
                                                     recipe.ptypes_interaction_matrix,
                                                     config.cells(),
                                                     allocations,
                                                     population)

    print_color('Population Fractions')
    print(fractions.to_string(max_rows=None))

    print('\n')

    print_color('Population Interactions')
    print(interactions
          .sort_values('absolute_difference', ascending=False)
          .to_string(max_rows=None))
    print_color('Mean absolute difference: %0.2f', interactions['absolute_difference'].abs().mean())


if __name__ == '__main__':
    cli(obj={})
