#!/usr/bin/env python
'''white-matter application'''
from __future__ import print_function
from contextlib import contextmanager

import logging
import os

import click
import numpy as np
import pandas as pd
from white_matter_projections import utils


L = logging.getLogger(__name__)
# Allow for matplotlib to be interactive or writing to file
plt = None


def print_color(s, *args, **kwargs):
    '''output text in green'''
    if args:
        s = s % args
    color = kwargs.get('color', 'green')
    click.echo(click.style(s, fg=color))


@click.group()
@click.version_option()
@click.option('-v', '--verbose', count=True)
@click.option('-m', '--interactive-matplotlib', is_flag=True)
@click.pass_context
def cli(ctx, verbose, interactive_matplotlib):
    '''cli'''
    global plt
    if not interactive_matplotlib:
        import matplotlib
        matplotlib.use('Agg')  # noqa

    import matplotlib.pyplot
    plt = matplotlib.pyplot

    if interactive_matplotlib:
        @contextmanager
        def figure(name):
            '''get a figure'''
            yield plt.figure()
            plt.show()
    else:
        @contextmanager
        def figure(name):
            '''get a figure'''
            plt.close('all')
            fig = plt.gcf()
            fig.set_size_inches(20, 20)
            fig.tight_layout()

            yield fig

            if not name.endswith('.png'):
                name += '.png'

            plt.savefig(name)
            print_color('Wrote: %s', name)

    ctx.obj['figure'] = figure

    logging.basicConfig(level=(logging.WARNING,
                               logging.INFO,
                               logging.DEBUG)[min(verbose, 2)],
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')


@cli.command()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def repl(ctx, config):
    import IPython

    config = utils.Config(config)
    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         config.recipe.layer_profiles)

    IPython.embed(banner1='You have access to: config, norm_layer_profiles')


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def macro(ctx, config):
    ctx.obj['config'] = utils.Config(config)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density(ctx, target):
    '''stacked target density

    Colored by source:
        1. MODULE
        2. LAYER (or subregion, i.e. 5it and 5pt are separate)
        3. REGION
    '''
    config, recipe = ctx.obj['config'], ctx.obj['config'].recipe

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         recipe.layer_profiles)

    name = 'stacked_region_%s' % target
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        stacked_density = recipe.get_target_region_density_sources(norm_layer_profiles, target)
        stacked_density.plot(kind='bar', stacked=True, ax=ax)
        ax.set_title('Vertical Profile of incoming regions for target: ' + target)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density_module(ctx, target):
    import altair as alt
    config, recipe = ctx.obj['config'], ctx.obj['config'].recipe

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         recipe.layer_profiles)

    stacked_density = recipe.get_target_region_density_modules(
        norm_layer_profiles, target, config.config['module_grouping'])

    stacked_density = (stacked_density
                       .T
                       .reset_index()
                       .melt('Source')
                       )
    order = alt.Order('Source', sort='ascending')
    chart = (alt.Chart(stacked_density)
             .properties(height=1000, width=400,
                         title='%s Layer by Source Population' % target)
             .mark_bar()
             .encode(
                 x=alt.X('Target:N', axis=alt.Axis(title='Layer')),
                 y=alt.Y('sum(value):Q', axis=alt.Axis(title='Density')),
                 color=alt.Color('Source'),
                 order=order,
                 tooltip=['Source', 'Target', 'value']
             )
             .save('stacked_density_%s.html' % target)
             )


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def connectivity(ctx, contra):
    from white_matter_projections import display
    config = ctx.obj['config']

    hemisphere = 'contra' if contra else 'ipsi'
    df = config.recipe.get_connection_density_map(hemisphere)
    df = utils.perform_module_grouping(df, config.config['module_grouping'])

    name = 'connectivity_%s' % hemisphere
    with ctx.obj['figure'](name) as fig:
        title = 'Connection synapse density - %s' % hemisphere
        display.draw_connectivity(fig, df, title, config.config['module_grouping_color'])


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def target_density(ctx, contra):
    import seaborn as sns
    config = ctx.obj['config']

    norm_layer_profiles = utils.normalize_layer_profiles(config.region_layer_heights,
                                                         config.recipe.layer_profiles)

    hemisphere = 'contra' if contra else 'ipsi'
    df = config.recipe.get_target_region_density(norm_layer_profiles, hemisphere)

    cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True, center='light')
    cmap.set_bad(color='white')
    df = df.replace(0., np.NaN)

    name = 'target_density_contra' if contra else 'target_density_ipsi'
    with ctx.obj['figure'](name) as fig:
        ax = fig.gca()
        sns.heatmap(df, cmap=cmap, square=True, xticklabels=1, yticklabels=1, linewidth=0.5, ax=ax)


@macro.command()
@click.pass_context
def source_mapping_triangles(ctx):
    from white_matter_projections import display

    name = 'src_mapping_triangles'
    with ctx.obj['figure'](name) as fig:
        display.plot_source_region_triangles(fig.gca(), ctx.obj['config'])


@macro.command()
@click.option('-p', '--population', required=True)
@click.pass_context
def stats(ctx, population):
    config = ctx.obj['config']

    region_names = set(config.recipe.populations.query('population == @population').subregion)
    region_names = region_names  # trick pylint

    sources = config.recipe.projections.query('source_population == @population')
    if len(sources):
        region_cells = config.cells().query('region in @region_names')
        print_color('Potential source cells in population: %d', len(region_cells))

        print_color('Projections with population as source:')
        out = sources.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['target_population', 'projection_name', 'target_density'])
        print(out)

    targets = config.recipe.projections.query('target_population == @population')
    if len(targets):
        region_cells = config.cells(include_all=True).query('region in @region_names')
        print_color('Potential target cells in population: %d', len(region_cells))

        print_color('Projections with population as target:')
        out = targets.sort_values('target_density').to_string(
            max_rows=None,
            index=False,
            columns=['source_population', 'projection_name', 'target_density'])
        print(out)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def micro(ctx, config, output):
    ctx.obj['config'] = utils.Config(config)
    ctx.obj['output'] = output
    utils.ensure_path(output)


@micro.command()
@click.pass_context
def allocate(ctx):
    from white_matter_projections import micro
    config, output = ctx.obj['config'], ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    if os.path.exists(allocations_path):
        print_color('Already have created %s, delete it if it needs to be recreated',
                    allocations_path, color='red')
        return

    allocations = micro.allocate_projections(config.recipe, config.cells())

    micro.save_allocations(allocations_path, allocations)


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.option('-o', '--output', required=True)
@click.pass_context
def analysis(ctx, config, output):
    '''analysis'''
    ctx.obj['config'] = utils.Config(config)
    assert os.path.exists(output)
    ctx.obj['output'] = output


@analysis.command()
@click.option('-p', '--population', required=True, default='ACAd_6')
@click.pass_context
def allocation_stats(ctx, population):
    from white_matter_projections import micro
    config, recipe, output = ctx.obj['config'], ctx.obj['config'].recipe, ctx.obj['output']

    allocations_path = os.path.join(output, 'allocations.h5')
    allocations = micro.load_allocations(allocations_path, recipe.projections_mapping)

    fractions, interactions = micro.allocation_stats(recipe.ptypes,
                                                     recipe.populations,
                                                     recipe.ptypes_interaction_matrix,
                                                     config.cells(),
                                                     allocations,
                                                     population)

    print_color('Population Fractions')
    print(fractions.to_string(max_rows=None))

    print('\n')

    print_color('Population Interactions')
    print(interactions
          .sort_values('absolute_difference', ascending=False)
          .to_string(max_rows=None))
    print_color('Mean absolute difference: %0.2f', interactions['absolute_difference'].abs().mean())


if __name__ == '__main__':
    cli(obj={})
