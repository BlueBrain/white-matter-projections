#!/usr/bin/env python
'''white-matter application'''

import logging
import itertools as it

import click
import numpy as np
import pandas as pd
from white_matter_projections import utils


L = logging.getLogger(__name__)
# Allow for matplotlib to be interactive or writing to file
plt = None


def print_green(s):
    '''output text in green'''
    click.echo(click.style(s, fg='green'))


@click.group()
@click.version_option()
@click.option('-v', '--verbose', count=True)
@click.option('-m', '--interactive-matplotlib', is_flag=True)
@click.pass_context
def cli(ctx, verbose, interactive_matplotlib):
    global plt
    if not interactive_matplotlib:
        import matplotlib
        matplotlib.use('Agg')  # noqa

    import matplotlib.pyplot
    plt = matplotlib.pyplot

    if interactive_matplotlib:
        def figure():
            return plt.figure()
        def display(_):
            plt.show()
    else:
        def figure():
            fig = plt.gcf()
            fig.set_size_inches(20, 20)
            fig.tight_layout()
            return fig
        def display(name):
            plt.savefig(name)
            click.echo(click.style('Wrote: %s' % name, fg='green'))


    ctx.obj['display'] = display
    ctx.obj['figure'] = figure

    logging.basicConfig(level=(logging.WARNING,
                               logging.INFO,
                               logging.DEBUG)[min(verbose, 2)],
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d %H:%M:%S')


@cli.command()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def repl(ctx, config):
    import IPython

    ctx.obj['config'] = _c = utils.Config(config)

    config = _c.config
    atlas = _c.atlas
    hier = _c.hierarchy
    recipe = _c.recipe
    layer_heights = _c.region_layer_heights
    del _c

    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    from bluepy.v2.circuit import Circuit
    cells = Circuit(config['circuit_config']).cells.get()

    IPython.embed(banner1='You have access to: atlas, cells, recipe, layer_heights, norm_layer_profiles')


@cli.group()
@click.option('-c', '--config', type=click.Path(exists=True), required=True)
@click.pass_context
def macro(ctx, config):
    ctx.obj['config'] = utils.Config(config)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density(ctx, target):
    '''stacked target density

    Colored by source:
        1. MODULE
        2. LAYER (or subregion, i.e. 5it and 5pt are separate)
        3. REGION
    '''
    recipe = ctx.obj['config'].recipe
    layer_heights = ctx.obj['config'].region_layer_heights

    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    fig = ctx.obj['figure']()
    ax = fig.gca()
    stacked_density = recipe.get_target_region_density_sources(norm_layer_profiles, target)
    stacked_density.plot(kind='bar', stacked=True, ax=ax)
    ax.set_title('Vertical Profile of incoming regions for target: ' + target)
    ctx.obj['display']('stacked_region_%s.png' % target)


@macro.command()
@click.option('-t', '--target', default='FRP')
@click.pass_context
def stacked_target_density_module(ctx, target):
    config = ctx.obj['config'].config
    recipe = ctx.obj['config'].recipe

    layer_heights = utils.region_layer_heights(config['region_layer_heights'])
    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    import altair as alt
    modules = config['module_grouping']
    stacked_density = recipe.get_target_region_density_modules(
        norm_layer_profiles, target, modules)

    stacked_density = (stacked_density
                       .T
                       .reset_index()
                       .melt('Source')
                       )
    order = alt.Order('Source', sort='ascending')
    chart = (alt.Chart(stacked_density)
             .properties(height=1000, width=400,
                         title='%s Layer by Source Population' % target)
             .mark_bar()
             .encode(
                 x=alt.X('Target:N', axis=alt.Axis(title='Layer')),
                 y=alt.Y('sum(value):Q', axis=alt.Axis(title='Density')),
                 color=alt.Color('Source'),
                 order=order,
                 tooltip=['Source', 'Target', 'value']
             )
             .save('stacked_density_%s.html' % target)
             )


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def connectivity(ctx, contra):
    from white_matter_projections import display
    config = ctx.obj['config'].config
    recipe = ctx.obj['config'].recipe

    hemisphere = 'contra' if contra else 'ipsi'
    df = recipe.get_connection_density_map(hemisphere)

    df = utils.perform_module_grouping(df, config['module_grouping'])

    fig = ctx.obj['figure']()

    title = 'Connection synapse density - ' + 'Contralateral' if contra else 'Ipsilateral'
    display.draw_connectivity(fig, df, title, config['module_grouping_color'])

    name = 'connectivity_contra.png' if contra else 'connectivity.png'
    ctx.obj['display'](name)


@macro.command()
@click.pass_context
@click.option('--contra', is_flag=True)
def target_density(ctx, contra):
    import seaborn as sns
    recipe = ctx.obj['config'].recipe
    layer_heights = ctx.obj['config'].region_layer_heights

    norm_layer_profiles = utils.normalize_layer_profiles(layer_heights, recipe.layer_profiles)

    hemisphere = 'contra' if contra else 'ipsi'
    df = recipe.get_target_region_density(norm_layer_profiles, hemisphere)

    cmap = sns.diverging_palette(220, 20, sep=20, as_cmap=True, center='light')
    cmap.set_bad(color='white')
    df = df.replace(0., np.NaN)

    fig = ctx.obj['figure']()
    ax = fig.gca()
    sns.heatmap(df, cmap=cmap, square=True, xticklabels=1, yticklabels=1, linewidth=0.5, ax=ax)
    name = 'target_density_contra.png' if contra else 'target_density.png'
    ctx.obj['display'](name)


@macro.command()
@click.pass_context
def source_mapping_triangles(ctx):
    from white_matter_projections import display, flat_mapping

    ax = plt.gca()
    ax.set_aspect('equal')
    flat_map = flat_mapping.load_100()
    display.plot_source_region_triangles(ax, ctx.obj['config'], flat_map)

    name = 'src_mapping_triangles.png'
    ctx.obj['display'](name)


@macro.command()
@click.option('-p', '--population', required=True)
@click.pass_context
def stats(ctx, population):
    config = ctx.obj['config']
    recipe, circuit = config.recipe, config.circuit

    cells = circuit.cells.get()
    region_names = set(recipe.populations.query('population == @population').subregion)  # noqa pylint: disable=unused-variable

    region_cells = cells.query('region in @region_names')

    print_green('Cells in population: %d' % len(region_cells))

    sources = recipe.projections.query('source_population == @population')
    if len(sources):
        print_green('Projections with population as source:')
        cols = ['target_population', 'projection_name', 'target_density']
        print(sources[cols])

    targets = recipe.projections.query('target_population == @population')
    if len(targets):
        print_green('Projections with population as target:')
        cols = ['source_population', 'projection_name', 'target_density']
        print(targets[cols])


if __name__ == '__main__':
    cli(obj={})
